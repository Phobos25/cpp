/*
 * Задача о расписании
 *  У программиста есть n заказов. Для каждого заказа известен дед-
 * лайн di — срок, до которого его надо выполнить, и его стоимость
 * ci. На выполнение каждого заказа требуется один день. Програм-
 * мист начинает работать с 1-го дня, и если у заказа дедлайн di, то
 * этот заказ нужно выполнить до конца di-го дня. Например, если
 * дедлайн заказа равен 1, то программист успеет его выполнить в
 * первый день. Нужно составить оптимальное расписание: опре-
 * делить, какие заказы программист может выполнять и в каком
 * порядке, чтобы максимизировать их суммарную стоимость
 */

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool sortbysec(const pair<int,int> &a,
              const pair<int,int> &b)
{
  // descending
  return (a.second > b.second);
}

int main() {
  int TMAX = 5;
  vector<int> d {1, 2, 2, 3, 5}; // дедлайны
  vector<int> c {2, 5, 4, 1, 3}; // стоимость
  /* для корректной работы жадного алгоритма
   * нам надо отсортировать вектора по стоимости,
   * чтобы заказ с наибольшей стоимости была вначале*/
  vector<bool> used(TMAX, false);
  // соберем два вектора в пару векторов для удобства
  vector<pair<int, int>> target(d.size());
  for (unsigned i = 0; i < target.size(); ++i){
    target[i] = make_pair(d[i], c[i]);
  }
  //  сортировка пары векторов по стоимости (второму вектору в парке)
  sort(target.begin(), target.end(), sortbysec);
  //  смотрим как выглядит вектор пар после сортировки
  for (auto [f, s]: target){
    cout << f << ' ' << s << endl;
  }

// Будем стараться выполнять заказы наибольшей стоимости
// но ставить их в последний возможный день
  long long sum = 0;
  int n = d.size();

  for (int i = 0; i< n; ++i){
    int k = target[i].first;
    while (k >= 1 && used [k]){
      --k;
    }
    if (k==0){
      continue;
    }
    used[k] = true;
    sum += target[i].second;
  }

  cout << sum;
  cout << endl;
  return 0;
}



